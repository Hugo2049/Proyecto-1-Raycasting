#[derive(Clone)] 

pub struct Map {
    pub width: usize,
    pub height: usize,
    pub data: Vec<Vec<u8>>,
}

impl Map {
    pub fn new(level: usize) -> Self {
        match level {
            0 => Self::level_1(),
            1 => Self::level_2(),
            2 => Self::level_3(),
            _ => Self::level_1(),
        }
    }

    fn level_1() -> Self {
        let data = vec![
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 1],
            vec![1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1],
            vec![1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 1],
            vec![1, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];
        
        Self {
            width: 16,
            height: 16,
            data,
        }
    }

    fn level_2() -> Self {
        let data = vec![
            vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
            vec![2, 0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0, 0, 2],
            vec![2, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 2],
            vec![2, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 2],
            vec![2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2],
            vec![2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2],
            vec![2, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 4, 2],
            vec![2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2],
            vec![2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2],
            vec![2, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 4, 2],
            vec![2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2],
            vec![2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2],
            vec![2, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 2],
            vec![2, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 2],
            vec![2, 0, 0, 0, 5, 5, 5, 0, 0, 5, 5, 5, 0, 0, 0, 2],
            vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
        ];
        
        Self {
            width: 16,
            height: 16,
            data,
        }
    }

    fn level_3() -> Self {
        let data = vec![
            vec![3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
            vec![3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
            vec![3, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 3],
            vec![3, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3],
            vec![3, 0, 1, 0, 0, 1, 0, 2, 2, 0, 1, 0, 0, 1, 0, 3],
            vec![3, 0, 1, 1, 0, 1, 0, 2, 2, 0, 1, 0, 1, 1, 0, 3],
            vec![3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
            vec![3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
            vec![3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
            vec![3, 0, 1, 1, 0, 1, 0, 2, 2, 0, 1, 0, 1, 1, 0, 3],
            vec![3, 0, 1, 0, 0, 1, 0, 2, 2, 0, 1, 0, 0, 1, 0, 3],
            vec![3, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3],
            vec![3, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 3],
            vec![3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
            vec![3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
            vec![3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        ];
        
        Self {
            width: 16,
            height: 16,
            data,
        }
    }

    pub fn get_cell(&self, x: usize, y: usize) -> u8 {
        if x >= self.width || y >= self.height {
            return 1; 
        }
        self.data[y][x]
    }

    pub fn is_wall(&self, x: usize, y: usize) -> bool {
        self.get_cell(x, y) > 0
    }

    pub fn get_coin_positions(&self) -> Vec<(f32, f32)> {
    let mut coins = Vec::new();
    
   
    match self.data[0][0] {
        1 => { 
            coins.push((12.5, 3.5));
            coins.push((5.5, 10.5));
            coins.push((12.5, 12.5))  
        }
        2 => { 
            coins.push((4.5, 4.5));
            coins.push((11.5, 4.5));
            coins.push((7.5, 7.5));    
            coins.push((4.5, 11.5));   
            coins.push((11.5, 11.5));
            coins.push((7.5, 4.5));     
        }
        3 => { 
            coins.push((5.5, 5.5));
            coins.push((10.5, 5.5));
            coins.push((8.5, 7.5));
            coins.push((5.5, 10.5));
            coins.push((10.5, 10.5));
            coins.push((8.5, 12.5)); 
            coins.push((4.5, 8.5));  
        }
        _ => {}
    }
    
    coins
}
}
